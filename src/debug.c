/*
 * Functions used for debugging purposes (e.g. printing backtraces).
 * Copyright (C)2013 Mike Bourgeous.  Released under AGPLv3 in 2018.
 */
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#include <signal.h>

#include "knd.h"

static struct sym_info *symbol_map;

/*
 * Adds a symbol, sorted by address, to the symbol map.  Insertion is O(n)
 * since symbols are in a simple linked list.  Returns 0 on success, positive
 * EINVAL if the symbol_line is not of the correct format, or a negated errno
 * value on any other error.
 */
static int add_symbol(char *symbol_line)
{
	struct sym_info *sym;
	size_t addr;

	sym = calloc(1, sizeof(struct sym_info));
	if(sym == NULL) {
		perror("Error allocating memory for symbol table entry");
		return -errno;
	}

	if(sscanf(symbol_line, "%zx%*[ \t]%*1s%*[ \t]%255s", &addr, sym->name) != 2) {
		free(sym);
		return EINVAL;
	}

	sym->addr = (void *)addr;

	if(symbol_map == NULL) {
		symbol_map = sym;
	} else {
		struct sym_info *ptr = symbol_map;

		while(ptr->next != NULL && ptr->addr < sym->addr) {
			ptr = ptr->next;
		}

		sym->next = ptr->next;
		ptr->next = sym;
	}

	return 0;
}

/*
 * Returns the symbol from the symbol map with the highest address that is less
 * than or equal to addr, excluding the _end symbol.  Returns NULL if there is
 * no such symbol.
 */
static struct sym_info *lookup_symbol(void *addr)
{
	struct sym_info *sym = symbol_map;

	if(sym == NULL || sym->addr > addr) {
		return NULL;
	}

	while(sym->next != NULL && sym->next->addr <= addr) {
		sym = sym->next;
	}

	if(sym->next == NULL && !strcmp(sym->name, "_end")) {
		return NULL;
	}

	return sym;
}

/*
 * Reads a symbol map from a file whose name is the name of the target of the
 * /proc/self/exe link with ".map" appended.  Returns the number of symbols
 * read on success, or a negated errno constant on error.  This function is not
 * reentrant.
 */
int load_symbols()
{
	char buf[512];
	ssize_t ret;
	FILE *map;
	int count = 0;

	// TODO: If this function is moved to nlutils, it should use lstat() to
	// get the actual link length as described in the readlink(2) manpage.
	ret = readlink("/proc/self/exe", buf, sizeof(buf));
	if(ret == -1) {
		perror("Error reading /proc/self/exe link");
		return -errno;
	}

	if(ret >= (int)sizeof(buf) - 5) {
		return -ENAMETOOLONG;
	}

	strcpy(buf + ret, ".map"); // adds terminating \0

	map = fopen(buf, "rt");
	if(map == NULL) {
		fprintf(stderr, "Error opening symbol map %s: %s\n", buf, strerror(errno));
		return -errno;
	}

	while(!feof(map) && !ferror(map)) {
		errno = 0;
		if(fgets(buf, sizeof(buf), map) == NULL) {
			if(feof(map)) {
				break;
			}
			perror("Error reading line from symbol map");
			fclose(map);
			return errno ? -errno : -EIO;
		}

		ret = add_symbol(buf);
		if(ret < 0) {
			fclose(map);
			return ret;
		} else if(ret == 0) {
			count++;
		}
	}

	fclose(map);

	return count;
}

/*
 * Deallocates all memory used by any symbol map previously loaded using
 * load_symbols().
 */
void unload_symbols()
{
	struct sym_info *sym;

	while(symbol_map != NULL) {
		sym = symbol_map;
		symbol_map = symbol_map->next;
		free(sym);
	}
}

/*
 * Stores information about the given address into the given Dl_info structure.
 * First checks with dladdr(), then if no match is found, checks the loaded
 * symbol table.  Returns zero on success, -1 if no match was found.  Does not
 * check for a NULL syminf pointer.
 */
int find_symbol(void *addr, Dl_info *syminf)
{
	Dl_info info;

	if(!dladdr(addr, &info)) {
		return -1;
	}

	if(info.dli_sname == NULL) {
		struct sym_info *sym = lookup_symbol(addr);
		if(sym != NULL) {
			info.dli_sname = sym->name;
			info.dli_saddr = sym->addr;
		} else {
			info.dli_sname = "[unknown]";
			info.dli_saddr = addr;
		}
	}

	*syminf = info;

	return 0;
}

/*
 * Prints the given stack trace (using fptmf() for timestamps).  The backtrace
 * may be generated by glibc's backtrace() method.  If a symbol map has been
 * loaded, it will be used to try to fill in symbol names that are missed by
 * dladdr().
 */
void print_backtrace(FILE *out, void **trace, int count)
{
	Dl_info info;
	int i;

	memset(&info, 0, sizeof(info));

	for(i = 0; i < count; i++) {
		if(!find_symbol(trace[i], &info)) {
			nl_fptmf(out, "%d: 0x%08zx - %s@0x%08zx - %s[0x%zx]+0x%tx\n",
					i, (size_t)trace[i],
					info.dli_fname, (size_t)info.dli_fbase,
					info.dli_sname, (size_t)info.dli_saddr,
					trace[i] - info.dli_saddr);
		} else {
			nl_fptmf(out, "%d: 0x%08zx - No symbol information\n", i, (size_t)trace[i]);
		}
	}
}

/*
 * Returns a string description of a non-signal-specific signal code.
 */
static const char *strsigcode_base(int si_code)
{
	switch(si_code) {
		case SI_USER:
			return "user-generated signal";
		case SI_KERNEL:
			return "kernel-generated signal";
		case SI_QUEUE:
			return "sigqueue-generated signal";
		case SI_TIMER:
			return "timer expired";
		case SI_MESGQ:
			return "message queue state changed";
		case SI_ASYNCIO:
			return "async I/O completed";
		case SI_SIGIO: // obsolete
			return "queued SIGIO";
		case SI_TKILL:
			return "tgkill-generated signal to thread";
	}

	return "[unknown]";
}

/*
 * Returns a pointer to a string describing the given signal and .si_code from
 * siginfo_t.
 */
const char *strsigcode(int signum, int si_code)
{
	// TODO: Move this to nlutils

	switch(signum) {
		case SIGILL:
			switch(si_code) {
				case ILL_ILLOPC:
					return "illegal opcode";
				case ILL_ILLOPN:
					return "illegal operand";
				case ILL_ILLADR:
					return "illegal addressing mode";
				case ILL_ILLTRP:
					return "illegal trap";
				case ILL_PRVOPC:
					return "privileged opcode";
				case ILL_PRVREG:
					return "privileged register";
				case ILL_COPROC:
					return "coprocessor error";
				case ILL_BADSTK:
					return "internal stack error";
			}
			break;

		case SIGFPE:
			switch(si_code) {
				case FPE_INTDIV:
					return "integer division by zero";
				case FPE_INTOVF:
					return "integer overflow";
				case FPE_FLTDIV:
					return "floating-point division by zero";
				case FPE_FLTOVF:
					return "floating-point overflow";
				case FPE_FLTUND:
					return "floating-point underflow";
				case FPE_FLTRES:
					return "inexact floating-point result";
				case FPE_FLTINV:
					return "invalid floating-point operation";
				case FPE_FLTSUB:
					return "subscript out of range";
			}
			break;

		case SIGSEGV:
			switch(si_code) {
				case SEGV_MAPERR:
					return "address not mapped to object";
				case SEGV_ACCERR:
					return "invalid permissions for mapped object";
			}
			break;

		case SIGBUS:
			switch(si_code) {
				case BUS_ADRALN:
					return "invalid address alignment";
				case BUS_ADRERR:
					return "nonexistent physical address";
				case BUS_OBJERR:
					return "object-specific hardware error";
#ifdef BUS_MCEERR_AR // FIXME: These are defined in a kernel header that conflicts with glibc
				case BUS_MCEERR_AR:
					return "hardware memory error consumed; action required";
#endif /* BUS_MCEERR_AR */
#ifdef BUS_MCEERR_AO
				case BUS_MCEERR_AO:
					return "hardware memory error detected; action optional";
#endif /* BUS_MCEERR_AO */
			}
			break;

		case SIGTRAP:
			switch(si_code) {
				case TRAP_BRKPT:
					return "process breakpoint";
				case TRAP_TRACE:
					return "process trace";
#ifdef TRAP_BRANCH // FIXME: These are defined in a kernel header that conflicts with glibc
				case TRAP_BRANCH:
					return "process branch taken";
#endif /* TRAP_BRANCH */
#ifdef TRAP_HWBKPT
				case TRAP_HWBKPT:
					return "hardware breakpoint";
#endif /* TRAP_HWBKPT */
			}
			break;

		case SIGCHLD:
			switch(si_code) {
				case CLD_EXITED:
					return "child exited";
				case CLD_KILLED:
					return "child killed";
				case CLD_DUMPED:
					return "child terminated abnormally";
				case CLD_TRAPPED:
					return "child trace trapped";
				case CLD_STOPPED:
					return "child stopped";
				case CLD_CONTINUED:
					return "child continued";
			}
			break;

		case SIGIO:
			switch(si_code) {
				case POLL_IN:
					return "data available";
				case POLL_OUT:
					return "output buffer available";
				case POLL_MSG:
					return "message available";
				case POLL_ERR:
					return "I/O error";
				case POLL_PRI:
					return "high priority input available";
				case POLL_HUP:
					return "device disconnected";
			}
			break;
	}

	return strsigcode_base(si_code);
}
