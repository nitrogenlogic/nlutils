/*
 * Functions used for debugging purposes (e.g. printing backtraces).
 * Copyright (C)2013 Mike Bourgeous.  Released under AGPLv3 in 2018.
 */
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#include <signal.h>

#include "nlutils.h"

/*
 * Information about a symbol within a symbol table.  See nl_load_symbols().
 */
struct nl_sym_info {
	char name[256];
	void *addr;

	struct nl_sym_info *next;
};

/*
 * A list of symbols read from the [executable name].map file, if it exists, by
 * nl_load_symbols().  Used by nl_find_symbol() and nl_print_backtrace() to
 * turn memory addresses into symbol names.
 */
static struct nl_sym_info *nl_symbol_map;

/*
 * Adds a symbol, sorted by address, to the symbol map.  Insertion is O(n)
 * since symbols are in a simple linked list, thus list creation is O(n^2).
 * Returns 0 on success, positive EINVAL if the symbol_line is not of the
 * correct format, or a negated errno value on any other error.
 */
static int nl_add_symbol(char *symbol_line)
{
	struct nl_sym_info *sym;
	size_t addr;

	sym = calloc(1, sizeof(struct nl_sym_info));
	if(sym == NULL) {
		ERRNO_OUT("Error allocating memory for symbol table entry");
		return -errno;
	}

	if(sscanf(symbol_line, "%zx%*[ \t]%*1s%*[ \t]%255s", &addr, sym->name) != 2) {
		free(sym);
		return EINVAL;
	}

	sym->addr = (void *)addr;

	if(nl_symbol_map == NULL) {
		nl_symbol_map = sym;
	} else {
		struct nl_sym_info *ptr = nl_symbol_map;

		while(ptr->next != NULL && ptr->addr < sym->addr) {
			ptr = ptr->next;
		}

		sym->next = ptr->next;
		ptr->next = sym;
	}

	return 0;
}

/*
 * Returns the symbol from the symbol map with the highest address that is less
 * than or equal to addr, excluding the _end symbol.  Returns NULL if there is
 * no such symbol.
 */
static struct nl_sym_info *nl_lookup_symbol(void *addr)
{
	struct nl_sym_info *sym = nl_symbol_map;

	if(sym == NULL || sym->addr > addr) {
		return NULL;
	}

	while(sym->next != NULL && sym->next->addr <= addr) {
		sym = sym->next;
	}

	if(sym->next == NULL && !strcmp(sym->name, "_end")) {
		return NULL;
	}

	return sym;
}

/*
 * Reads a symbol map from a file whose name is the name of the target of the
 * /proc/self/exe link with ".map" appended.  The symbol map should have been
 * generated by the nm command.  Returns the number of symbols read on success,
 * or a negated errno constant on error.  Call this at application start to
 * allow later use of functions like nl_print_backtrace().  This function is not
 * reentrant.
 *
 * FIXME: this doesn't work at all; it doesn't take into account which section
 * a symbol came from, nor does it compensate for the base address at which
 * that section is mapped.
 */
int nl_load_symbols(void)
{
	char buf[512];
	ssize_t ret;
	FILE *map;
	int count = 0;

	// TODO: If this function is moved to nlutils, it should use lstat() to
	// get the actual link length as described in the readlink(2) manpage.
	ret = readlink("/proc/self/exe", buf, sizeof(buf));
	if(ret == -1) {
		perror("Error reading /proc/self/exe link");
		return -errno;
	}

	if(ret >= (int)sizeof(buf) - 5) {
		return -ENAMETOOLONG;
	}

	strcpy(buf + ret, ".map"); // adds terminating \0

	map = fopen(buf, "rt");
	if(map == NULL) {
		fprintf(stderr, "Error opening symbol map %s: %s\n", buf, strerror(errno));
		return -errno;
	}

	while(!feof(map) && !ferror(map)) {
		errno = 0;
		if(fgets(buf, sizeof(buf), map) == NULL) {
			if(feof(map)) {
				break;
			}
			perror("Error reading line from symbol map");
			fclose(map);
			return errno ? -errno : -EIO;
		}

		ret = nl_add_symbol(buf);
		if(ret < 0) {
			fclose(map);
			return ret;
		} else if(ret == 0) {
			count++;
		}
	}

	fclose(map);

	return count;
}

/*
 * Deallocates all memory used by any symbol map previously loaded using
 * nl_load_symbols().  Call this at application exit if nl_load_symbols() was
 * called.
 */
void nl_unload_symbols(void)
{
	struct nl_sym_info *sym;

	while(nl_symbol_map != NULL) {
		sym = nl_symbol_map;
		nl_symbol_map = nl_symbol_map->next;
		free(sym);
	}
}

/*
 * Stores information about the given address into the given Dl_info structure.
 * First checks with dladdr(), then if no match is found, checks the symbol
 * table loaded by nl_load_symbols().  Returns zero on success, -1 if the
 * address is not mapped or if syminf was NULL.
 */
int nl_find_symbol(void *addr, Dl_info *syminf)
{
	Dl_info info;

	if(CHECK_NULL(syminf)) {
		return -1;
	}

	if(!dladdr(addr, &info)) {
		return -1;
	}

	if(info.dli_sname == NULL) {
		struct nl_sym_info *sym = nl_lookup_symbol(addr);
		if(sym != NULL) {
			info.dli_sname = sym->name;
			info.dli_saddr = sym->addr;
		} else {
			info.dli_sname = "[unknown]";
			info.dli_saddr = addr;
		}
	}

	*syminf = info;

	return 0;
}

/*
 * Prints the given stack trace (using nl_fptmf() for timestamps).  The
 * backtrace should be generated by glibc's backtrace() method.  If a symbol
 * map has been loaded using nl_load_symbols(), it will be used to try to fill
 * in symbol names that are missed by dladdr().
 */
void nl_print_backtrace(FILE *out, void **trace, int count)
{
	Dl_info info;
	int i;

	memset(&info, 0, sizeof(info));

	for(i = 0; i < count; i++) {
		if(!nl_find_symbol(trace[i], &info)) {
			nl_fptmf(out, "%d: 0x%08zx - %s@0x%08zx - %s[0x%zx]+0x%tx\n",
					i, (size_t)trace[i],
					info.dli_fname, (size_t)info.dli_fbase,
					info.dli_sname, (size_t)info.dli_saddr,
					trace[i] - info.dli_saddr);
		} else {
			nl_fptmf(out, "%d: 0x%08zx - No symbol information\n", i, (size_t)trace[i]);
		}
	}
}

/*
 * Returns a string description of a non-signal-specific signal code.
 */
static const char *nl_strsigcode_base(int si_code)
{
	switch(si_code) {
		case SI_USER:
			return "user-generated signal";
		case SI_KERNEL:
			return "kernel-generated signal";
		case SI_QUEUE:
			return "sigqueue-generated signal";
		case SI_TIMER:
			return "timer expired";
		case SI_MESGQ:
			return "message queue state changed";
		case SI_ASYNCIO:
			return "async I/O completed";
		case SI_SIGIO: // obsolete
			return "queued SIGIO";
		case SI_TKILL:
			return "tgkill-generated signal to thread";
	}

	return "[unknown]";
}

/*
 * Returns a pointer to a string describing the given .si_signo and .si_code
 * from siginfo_t.  See the manual page for sigaction().
 */
const char *nl_strsigcode(int signum, int si_code)
{
	switch(signum) {
		case SIGILL:
			switch(si_code) {
				case ILL_ILLOPC:
					return "illegal opcode";
				case ILL_ILLOPN:
					return "illegal operand";
				case ILL_ILLADR:
					return "illegal addressing mode";
				case ILL_ILLTRP:
					return "illegal trap";
				case ILL_PRVOPC:
					return "privileged opcode";
				case ILL_PRVREG:
					return "privileged register";
				case ILL_COPROC:
					return "coprocessor error";
				case ILL_BADSTK:
					return "internal stack error";
			}
			break;

		case SIGFPE:
			switch(si_code) {
				case FPE_INTDIV:
					return "integer division by zero";
				case FPE_INTOVF:
					return "integer overflow";
				case FPE_FLTDIV:
					return "floating-point division by zero";
				case FPE_FLTOVF:
					return "floating-point overflow";
				case FPE_FLTUND:
					return "floating-point underflow";
				case FPE_FLTRES:
					return "inexact floating-point result";
				case FPE_FLTINV:
					return "invalid floating-point operation";
				case FPE_FLTSUB:
					return "subscript out of range";
			}
			break;

		case SIGSEGV:
			switch(si_code) {
				case SEGV_MAPERR:
					return "address not mapped to object";
				case SEGV_ACCERR:
					return "invalid permissions for mapped object";
			}
			break;

		case SIGBUS:
			switch(si_code) {
				case BUS_ADRALN:
					return "invalid address alignment";
				case BUS_ADRERR:
					return "nonexistent physical address";
				case BUS_OBJERR:
					return "object-specific hardware error";
#ifdef BUS_MCEERR_AR // FIXME: These are defined in a kernel header that conflicts with glibc
				case BUS_MCEERR_AR:
					return "hardware memory error consumed; action required";
#endif /* BUS_MCEERR_AR */
#ifdef BUS_MCEERR_AO
				case BUS_MCEERR_AO:
					return "hardware memory error detected; action optional";
#endif /* BUS_MCEERR_AO */
			}
			break;

		case SIGTRAP:
			switch(si_code) {
				case TRAP_BRKPT:
					return "process breakpoint";
				case TRAP_TRACE:
					return "process trace";
#ifdef TRAP_BRANCH // FIXME: These are defined in a kernel header that conflicts with glibc
				case TRAP_BRANCH:
					return "process branch taken";
#endif /* TRAP_BRANCH */
#ifdef TRAP_HWBKPT
				case TRAP_HWBKPT:
					return "hardware breakpoint";
#endif /* TRAP_HWBKPT */
			}
			break;

		case SIGCHLD:
			switch(si_code) {
				case CLD_EXITED:
					return "child exited";
				case CLD_KILLED:
					return "child killed";
				case CLD_DUMPED:
					return "child terminated abnormally";
				case CLD_TRAPPED:
					return "child trace trapped";
				case CLD_STOPPED:
					return "child stopped";
				case CLD_CONTINUED:
					return "child continued";
			}
			break;

		case SIGIO:
			switch(si_code) {
				case POLL_IN:
					return "data available";
				case POLL_OUT:
					return "output buffer available";
				case POLL_MSG:
					return "message available";
				case POLL_ERR:
					return "I/O error";
				case POLL_PRI:
					return "high priority input available";
				case POLL_HUP:
					return "device disconnected";
			}
			break;
	}

	return nl_strsigcode_base(si_code);
}
