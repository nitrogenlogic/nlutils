/*
 * Functions used for debugging purposes (e.g. printing backtraces).
 * Copyright (C)2013, 2018 Mike Bourgeous.  Released under AGPLv3 in 2018.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#include <signal.h>
#include <stddef.h>

#include "nlutils.h"

#define ADDR_FORMAT "0x%08" PRIxPTR
#define SYM_FORMAT "%s@" ADDR_FORMAT

/*
 * Prints information about the given address, including symbol information for
 * the address if available.
 */
static void nl_print_address(FILE *out, const char *desc, void *addr)
{
	Dl_info syminfo;
	if(dladdr(addr, &syminfo)) {
		nl_fptmf(out, "%s: " ADDR_FORMAT " (" SYM_FORMAT " from " SYM_FORMAT ").\n",
				desc, (uintptr_t)addr,
				GUARD_NULL(syminfo.dli_sname), (uintptr_t)syminfo.dli_saddr,
				GUARD_NULL(syminfo.dli_fname), (uintptr_t)syminfo.dli_fbase);
	} else {
		nl_fptmf(out, "%s: " ADDR_FORMAT " (no matching symbol found).\n",
				desc, (uintptr_t)addr);
	}
}

/*
 * Prints information about the given signal to the given file.  Useful in
 * signal handlers set by sigaction().  Uses nl_fptmf() to add thread name and
 * timestamp.  This function voids allocating memory, for safe use in signal
 * handlers.
 *
 * Parameters:
 *   out - Where to write the signal info
 *   msg - Text to include at the beginning of the signal message printed
 *   info - Detailed signal info, or NULL (see the sigaction() manual page)
 *
 * Example:
 *     nl_print_signal("Crashing due to", &(siginfo_t){.si_signo = SIGSEGV})
 *
 * Output:
 *     Crashing due to segmentation fault (11), code 0 (user-generated signal), at address 0x00000000.
 *     Originating address: 0x00000000 (no matching symbol found).
 */
void nl_print_signal(FILE *out, char *msg, siginfo_t *info)
{
	if(CHECK_NULL(info)) {
		return;
	}

	nl_fptmf(out, "%s %s (%d), code %d (%s), at address " ADDR_FORMAT ".\n",
			msg, strsignal(info->si_signo), info->si_signo,
			info->si_code, nl_strsigcode(info->si_signo, info->si_code), (uintptr_t)info->si_addr);

	nl_print_address(out, "Originating address", info->si_addr);
}

/*
 * Prints information about the given execution context to the given file.
 * Useful in signal handlers set by sigaction().  Uses nl_fptmf() to add thread
 * name and timestamp.  This function voids allocating memory, for safe use in
 * signal handlers.
 *
 * Parameters:
 *   out - Where to write the context info
 *   ctx - Execution context info, or NULL (see the sigaction() manual page)
 *
 * Example:
 *     ucontext_t ctx;
 *     getcontext(&ctx);
 *     nl_print_context(&ctx)
 *
 * Output (x86_64):
 *     Instruction pointer: 0x12345678 (main@0x12345600 from ./blah@0x12340000).
 *     Stack pointer: 0x87654000 (no matching symbol found).
 */
void nl_print_context(FILE *out, ucontext_t *ctx)
{
	if(CHECK_NULL(ctx)) {
		return;
	}

#if defined(__arm__)
	nl_print_address(out, "Program counter", (void *)ctx->uc_mcontext.arm_pc);
	nl_print_address(out, "Link register", (void *)ctx->uc_mcontext.arm_lr);
	nl_print_address(out, "Stack pointer", (void *)ctx->uc_mcontext.arm_sp);
#elif defined(__x86_64__) || defined(__i386__)
# ifdef __x86_64__
	greg_t ip = ctx->uc_mcontext.gregs[REG_RIP];
	greg_t sp = ctx->uc_mcontext.gregs[REG_RSP];
# else /* __x86_64__ */
	greg_t ip = ctx->uc_mcontext.gregs[REG_EIP];
	greg_t sp = ctx->uc_mcontext.gregs[REG_ESP];
# endif /* __x86_64__ */
	nl_print_address(out, "Instruction pointer", (void *)ip);
	nl_print_address(out, "Stack pointer", (void *)sp);
#else /* __arm__ */
	nl_fptmf(out, "Architecture not supported\n");
#endif /* __arm__ */
}

/*
 * Prints the given stack trace (using nl_fptmf() for timestamps).  The trace
 * should usually be generated by glibc's backtrace() method, but in reality
 * any list of addresses can be provided.  The advantages of this function over
 * backtrace_symbols_fd() are the use of timestamps, and the inclusion of
 * additional detail including the name of the current thread.
 */
void nl_print_backtrace(FILE *out, void **trace, int count)
{
	Dl_info info;
	int i;

	memset(&info, 0, sizeof(info));

	for(i = 0; i < count; i++) {
		if(dladdr(trace[i], &info)) {
			nl_fptmf(out, "%d: 0x%08" PRIxPTR " - %s@0x%08" PRIxPTR " - %s[0x%" PRIxPTR "]+0x%tx\n",
					i, (uintptr_t)trace[i],
					GUARD_NULL(info.dli_fname), (uintptr_t)info.dli_fbase,
					GUARD_NULL(info.dli_sname), (uintptr_t)info.dli_saddr,
					trace[i] - info.dli_saddr);
		} else {
			nl_fptmf(out, "%d: 0x%08" PRIxPTR " - No symbol information\n", i, (uintptr_t)trace[i]);
		}
	}
}

/*
 * Returns a string description of a non-signal-specific signal code.
 */
static const char *nl_strsigcode_base(int si_code)
{
	switch(si_code) {
		case SI_USER:
			return "user-generated signal";
		case SI_KERNEL:
			return "kernel-generated signal";
		case SI_QUEUE:
			return "sigqueue-generated signal";
		case SI_TIMER:
			return "timer expired";
		case SI_MESGQ:
			return "message queue state changed";
		case SI_ASYNCIO:
			return "async I/O completed";
		case SI_SIGIO: // obsolete
			return "queued SIGIO";
		case SI_TKILL:
			return "tgkill-generated signal to thread";
	}

	return "[unknown]";
}

/*
 * Returns a pointer to a string describing the given .si_signo and .si_code
 * from siginfo_t.  See the manual page for sigaction().
 */
const char *nl_strsigcode(int signum, int si_code)
{
	switch(signum) {
		case SIGILL:
			switch(si_code) {
				case ILL_ILLOPC:
					return "illegal opcode";
				case ILL_ILLOPN:
					return "illegal operand";
				case ILL_ILLADR:
					return "illegal addressing mode";
				case ILL_ILLTRP:
					return "illegal trap";
				case ILL_PRVOPC:
					return "privileged opcode";
				case ILL_PRVREG:
					return "privileged register";
				case ILL_COPROC:
					return "coprocessor error";
				case ILL_BADSTK:
					return "internal stack error";
			}
			break;

		case SIGFPE:
			switch(si_code) {
				case FPE_INTDIV:
					return "integer division by zero";
				case FPE_INTOVF:
					return "integer overflow";
				case FPE_FLTDIV:
					return "floating-point division by zero";
				case FPE_FLTOVF:
					return "floating-point overflow";
				case FPE_FLTUND:
					return "floating-point underflow";
				case FPE_FLTRES:
					return "inexact floating-point result";
				case FPE_FLTINV:
					return "invalid floating-point operation";
				case FPE_FLTSUB:
					return "subscript out of range";
			}
			break;

		case SIGSEGV:
			switch(si_code) {
				case SEGV_MAPERR:
					return "address not mapped to object";
				case SEGV_ACCERR:
					return "invalid permissions for mapped object";
			}
			break;

		case SIGBUS:
			switch(si_code) {
				case BUS_ADRALN:
					return "invalid address alignment";
				case BUS_ADRERR:
					return "nonexistent physical address";
				case BUS_OBJERR:
					return "object-specific hardware error";
#ifdef BUS_MCEERR_AR // FIXME: These are defined in a kernel header that conflicts with glibc
				case BUS_MCEERR_AR:
					return "hardware memory error consumed; action required";
#endif /* BUS_MCEERR_AR */
#ifdef BUS_MCEERR_AO
				case BUS_MCEERR_AO:
					return "hardware memory error detected; action optional";
#endif /* BUS_MCEERR_AO */
			}
			break;

		case SIGTRAP:
			switch(si_code) {
				case TRAP_BRKPT:
					return "process breakpoint";
				case TRAP_TRACE:
					return "process trace";
#ifdef TRAP_BRANCH // FIXME: These are defined in a kernel header that conflicts with glibc
				case TRAP_BRANCH:
					return "process branch taken";
#endif /* TRAP_BRANCH */
#ifdef TRAP_HWBKPT
				case TRAP_HWBKPT:
					return "hardware breakpoint";
#endif /* TRAP_HWBKPT */
			}
			break;

		case SIGCHLD:
			switch(si_code) {
				case CLD_EXITED:
					return "child exited";
				case CLD_KILLED:
					return "child killed";
				case CLD_DUMPED:
					return "child terminated abnormally";
				case CLD_TRAPPED:
					return "child trace trapped";
				case CLD_STOPPED:
					return "child stopped";
				case CLD_CONTINUED:
					return "child continued";
			}
			break;

		case SIGIO:
			switch(si_code) {
				case POLL_IN:
					return "data available";
				case POLL_OUT:
					return "output buffer available";
				case POLL_MSG:
					return "message available";
				case POLL_ERR:
					return "I/O error";
				case POLL_PRI:
					return "high priority input available";
				case POLL_HUP:
					return "device disconnected";
			}
			break;
	}

	return nl_strsigcode_base(si_code);
}
