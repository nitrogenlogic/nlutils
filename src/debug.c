/*
 * Functions used for debugging purposes (e.g. printing backtraces).
 * Copyright (C)2013 Mike Bourgeous.  Released under AGPLv3 in 2018.
 */
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#include <signal.h>

#include "nlutils.h"

/*
 * Prints the given stack trace (using nl_fptmf() for timestamps).  The
 * backtrace should be generated by glibc's backtrace() method.  If a symbol
 * map has been loaded using nl_load_symbols(), it will be used to try to fill
 * in symbol names that are missed by dladdr().
 */
void nl_print_backtrace(FILE *out, void **trace, int count)
{
	Dl_info info;
	int i;

	memset(&info, 0, sizeof(info));

	for(i = 0; i < count; i++) {
		if(dladdr(trace[i], &info)) {
			nl_fptmf(out, "%d: 0x%08zx - %s@0x%08zx - %s[0x%zx]+0x%tx\n",
					i, (size_t)trace[i],
					info.dli_fname, (size_t)info.dli_fbase,
					info.dli_sname, (size_t)info.dli_saddr,
					trace[i] - info.dli_saddr);
		} else {
			nl_fptmf(out, "%d: 0x%08zx - No symbol information\n", i, (size_t)trace[i]);
		}
	}
}

/*
 * Returns a string description of a non-signal-specific signal code.
 */
static const char *nl_strsigcode_base(int si_code)
{
	switch(si_code) {
		case SI_USER:
			return "user-generated signal";
		case SI_KERNEL:
			return "kernel-generated signal";
		case SI_QUEUE:
			return "sigqueue-generated signal";
		case SI_TIMER:
			return "timer expired";
		case SI_MESGQ:
			return "message queue state changed";
		case SI_ASYNCIO:
			return "async I/O completed";
		case SI_SIGIO: // obsolete
			return "queued SIGIO";
		case SI_TKILL:
			return "tgkill-generated signal to thread";
	}

	return "[unknown]";
}

/*
 * Returns a pointer to a string describing the given .si_signo and .si_code
 * from siginfo_t.  See the manual page for sigaction().
 */
const char *nl_strsigcode(int signum, int si_code)
{
	switch(signum) {
		case SIGILL:
			switch(si_code) {
				case ILL_ILLOPC:
					return "illegal opcode";
				case ILL_ILLOPN:
					return "illegal operand";
				case ILL_ILLADR:
					return "illegal addressing mode";
				case ILL_ILLTRP:
					return "illegal trap";
				case ILL_PRVOPC:
					return "privileged opcode";
				case ILL_PRVREG:
					return "privileged register";
				case ILL_COPROC:
					return "coprocessor error";
				case ILL_BADSTK:
					return "internal stack error";
			}
			break;

		case SIGFPE:
			switch(si_code) {
				case FPE_INTDIV:
					return "integer division by zero";
				case FPE_INTOVF:
					return "integer overflow";
				case FPE_FLTDIV:
					return "floating-point division by zero";
				case FPE_FLTOVF:
					return "floating-point overflow";
				case FPE_FLTUND:
					return "floating-point underflow";
				case FPE_FLTRES:
					return "inexact floating-point result";
				case FPE_FLTINV:
					return "invalid floating-point operation";
				case FPE_FLTSUB:
					return "subscript out of range";
			}
			break;

		case SIGSEGV:
			switch(si_code) {
				case SEGV_MAPERR:
					return "address not mapped to object";
				case SEGV_ACCERR:
					return "invalid permissions for mapped object";
			}
			break;

		case SIGBUS:
			switch(si_code) {
				case BUS_ADRALN:
					return "invalid address alignment";
				case BUS_ADRERR:
					return "nonexistent physical address";
				case BUS_OBJERR:
					return "object-specific hardware error";
#ifdef BUS_MCEERR_AR // FIXME: These are defined in a kernel header that conflicts with glibc
				case BUS_MCEERR_AR:
					return "hardware memory error consumed; action required";
#endif /* BUS_MCEERR_AR */
#ifdef BUS_MCEERR_AO
				case BUS_MCEERR_AO:
					return "hardware memory error detected; action optional";
#endif /* BUS_MCEERR_AO */
			}
			break;

		case SIGTRAP:
			switch(si_code) {
				case TRAP_BRKPT:
					return "process breakpoint";
				case TRAP_TRACE:
					return "process trace";
#ifdef TRAP_BRANCH // FIXME: These are defined in a kernel header that conflicts with glibc
				case TRAP_BRANCH:
					return "process branch taken";
#endif /* TRAP_BRANCH */
#ifdef TRAP_HWBKPT
				case TRAP_HWBKPT:
					return "hardware breakpoint";
#endif /* TRAP_HWBKPT */
			}
			break;

		case SIGCHLD:
			switch(si_code) {
				case CLD_EXITED:
					return "child exited";
				case CLD_KILLED:
					return "child killed";
				case CLD_DUMPED:
					return "child terminated abnormally";
				case CLD_TRAPPED:
					return "child trace trapped";
				case CLD_STOPPED:
					return "child stopped";
				case CLD_CONTINUED:
					return "child continued";
			}
			break;

		case SIGIO:
			switch(si_code) {
				case POLL_IN:
					return "data available";
				case POLL_OUT:
					return "output buffer available";
				case POLL_MSG:
					return "message available";
				case POLL_ERR:
					return "I/O error";
				case POLL_PRI:
					return "high priority input available";
				case POLL_HUP:
					return "device disconnected";
			}
			break;
	}

	return nl_strsigcode_base(si_code);
}
