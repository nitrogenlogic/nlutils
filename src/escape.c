/*
 * String escaping/unescaping utilities.
 * Copyright (C)2013 Mike Bourgeous.  Released under AGPLv3 in 2018.
 */
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "nlutils.h"

/*
 * The character to use for escaping characters from esc_chars.
 */
static const char escape_char = '\\';

/*
 * Table of characters to escape, used by string escaping functions.  Even
 * indexes are the character to escape, odd indexes are the character to use
 * instead (plus the escape character, which is usually a backslash).
 */
static const char esc_chars[] = {
	'\t', 't',
	'\n', 'n',
	'\r', 'r',
	'\v', 'v',
	'\f', 'f',
	':', ':', // This is a legacy remnant from the Automation Controller's object serialization format
	'"', '"',
	'\\', '\\', // Make sure escape_char is in this table
	// TODO: Add all escape sequences that may be generated by Ruby's String#inspect method (including \a, \b, \uNNNN).
};

// TODO: Make generic versions of nl_count_escapes and nl_escape_string that use an escape table parameter

/*
 * Returns the replacement character for the given character, or 0 if the given
 * character is not in the escape table.
 */
static inline char get_escape(char c)
{
	size_t i;

	for(i = 0; i < ARRAY_SIZE(esc_chars); i += 2) {
		if(esc_chars[i] == c) {
			return esc_chars[i + 1];
		}
	}

	return 0;
}

/*
 * Returns the original character for the given escaped character, or 0 if the
 * given character is not in the escape table.
 */
static inline char get_original(char c)
{
	size_t i;

	for(i = 1; i < ARRAY_SIZE(esc_chars); i += 2) {
		if(esc_chars[i] == c) {
			return esc_chars[i - 1];
		}
	}

	return 0;
}

/*
 * Returns the number of additional bytes needed to escape the given string for
 * serialization safety.  Does not check to see if str is NULL.
 */
int nl_count_escapes(char *str)
{
	int count = 0;

	while(*str != 0) {
		if(get_escape(*str)) {
			count++;
		}
		str++;
	}

	return count;
}

/*
 * Escapes serialization-unsafe characters in the given string, expanding it
 * using realloc() if more than *size bytes are required (including the
 * terminating zero byte).  If the string is resized, the new size is stored in
 * *size, and the new pointer is stored in *str.  Returns 0 on success, or -1
 * if a temporary expansion buffer couldn't be allocated or the string buffer
 * couldn't be resized.  Use nl_escape_string() only for 0-terminated strings.
 */
int nl_escape_string(char **str, size_t *size)
{
	char *tmp;	// Temporary allocated buffer
	char *ptr;	// Pointer to current character in *str
	char *ptr2;	// Pointer to current character in tmp
	char replace;	// Replacement character from get_escape()
	size_t len;

	if(str == NULL || *str == NULL) {
		ERROR_OUT("Null string parameter\n");
		return -1;
	}
	if(size == NULL) {
		ERROR_OUT("Null size parameter\n");
		return -1;
	}

	// There's probably a way to speed this up, like integrating counting,
	// buffer reallocation, and escaping into a single loop, and unrolling
	// loops to allow use of memcpy and/or 32- or 64-bit memory operations.
	// A 256-entry table could also be created so that escape characters
	// are discovered by an array lookup rather than a loop.
	
	// TODO: Run some benchmarks to see if doing an in-place replacement in
	// reverse order (like nl_escape_data()) would be better

	// Expand the string buffer
	len = strlen(*str) + nl_count_escapes(*str) + 1;
	if(len > *size) {
		tmp = realloc(*str, len);
		if(tmp == NULL) {
			ERRNO_OUT("Error resizing string buffer from %zu to %zu", *size, len);
			return -1;
		}
		*str = tmp;
		*size = len;
	}

	// Allocate temporary buffer
	tmp = nl_strdup(*str);
	if(tmp == NULL) {
		ERROR_OUT("Error allocating temporary string copy\n");
		return -1;
	}

	// Copy data with escaping
	ptr = *str;
	ptr2 = tmp;
	while(*ptr2 != 0) {
		replace = get_escape(*ptr2);
		if(replace) {
			ptr[0] = escape_char;
			ptr[1] = replace;
			ptr += 2;
		} else {
			*ptr = *ptr2;
			ptr++;
		}
		ptr2++;
	}
	*ptr = 0;

	free(tmp);
	return 0;
}

/*
 * De-escapes the given string, using the same set of escaped characters as
 * nl_escape_string().  If include_zero is nonzero, then zero bytes (which
 * would normally indicate the end of a string) will be included in the output.
 * If the string included any escaped zero bytes, the number of removed
 * characters can be used to determine the actual length of the resulting data.
 * If dequote is ESCAPE_DEQUOTE, then surrounding quotation marks, if present,
 * will be removed.  If dequote is ESCAPE_IF_QUOTED, then unescaping will only
 * occur if the string is quoted.  Non-escaped quotation marks in the middle of
 * a string are left unmodified.  If a leading quotation mark is found but a
 * trailing quotation mark is escaped or absent, the leading quotation mark is
 * still removed.  Returns the number of characters removed from the string, or
 * -1 if str is NULL.
 */
int nl_unescape_string(char *str, int include_zero, enum nl_unescape_dequote dequote)
{
	char *write = str;
	char replace;
	int count = 0;
	char buf[3];
	int hexval;

	if(str == NULL) {
		ERROR_OUT("Null string parameter\n");
		return -1;
	}

	// Clear hexadecimal replacement buffer
	buf[0] = 0;
	buf[1] = 0;
	buf[2] = 0;

	// See if the string starts with a quotation mark
	if(dequote) {
		if(str[0] == '"') {
			str++;
			count++;
		} else {
			if(dequote == ESCAPE_IF_QUOTED) {
				return 0;
			}
			dequote = 0;
		}
	}

	// Go to the first escape character or the trailing quotation mark
	if(dequote) {
		while(*str != escape_char && *str != 0 && *str != '"') {
			// FIXME: this will stop at a quotation mark that is
			// not the trailing quotation mark, but this should not
			// affect the result.
			*write++ = *str++;
		}
	} else {
		while(*str != escape_char && *str != 0) {
			write++;
			str++;
		}
	}

	// No doubt this could be made more efficient by consolidating common
	// logic from the various execution paths and using something more
	// optimized than get_original(), if this code proves to be a source of
	// slowness.
	// TODO: This code is functional, but convoluted.  Clean it up.
	while(*str != 0) {
		if(*str == escape_char) {
			if(str[1] == 'x') {
				// Hexadecimal escape
				// TODO: Provide a string_to_data function that handles \x00 (using strlen() - removed) and \0
				
				if(isxdigit(str[2])) {
					buf[0] = str[2];

					if(isxdigit(str[3])) {
						buf[1] = str[3];
						str += 4;
						count += 3;
					} else {
						buf[1] = 0;
						str += 3;
						count += 2;
					}

					hexval = strtoul(buf, NULL, 16);
					if(hexval || include_zero) {
						*write = strtoul(buf, NULL, 16);
						write++;
					} else {
						// Don't write \x00 into middle of string unless requested
						DEBUG_OUT("Consuming \\x00\n");
						count++;
					}
				} else {
					DEBUG_OUT("Hexadecimal escape with no valid hex digits\n");
					write[0] = str[0];
					write[1] = str[1];
					write += 2;
					str += 2;
				}
			} else {
				// Standard escape
				replace = get_original(str[1]);
				if(!replace) {
#ifdef DEBUG
					snprintf(buf, ARRAY_SIZE(buf), "%02x", str[1]);
					if(!isprint(str[1])) {
						DEBUG_OUT("Unrecognized escape sequence: \"%c\\x%s\"\n",
								escape_char, buf);
					} else {
						DEBUG_OUT("Unrecognized escape sequence: \"%c%c\"\n", escape_char, str[1]);
					}
#endif /* DEBUG */

					write[0] = str[0];
					write[1] = str[1];
					
					// Handle escaped end of string
					if(str[1] == 0) {
						write++;
						break;
					}

					write += 2;
				} else {
					*write = replace;
					write++;
					count++;
				}
				str += 2;
			}
		} else if(dequote && *str == '"' && str[1] == 0) {
			// Trailing quotation mark
			str++;
			count++;
		} else {
			// Ordinary character
			*write = *str;
			str++;
			write++;
		}
	}
	*write = 0;

	return count;
}

/*
 * Returns the number of additional bytes needed to escape all non-printable
 * characters in the given data.  Does not check to see if data is NULL.
 */
size_t nl_count_data_escapes(const char *data, size_t data_size)
{
	size_t count = 0;
	size_t i;

	for(i = 0; i < data_size; i++) {
		// Process common escape sequences ('\n', etc.) except for the colon
		// used in serialization, and replace other unprintables with
		// hex escape sequences
		if(data[i] != ':' && get_escape(data[i]) != 0) {
			count++;
		} else if(data[i] < 0x20 || data[i] > 0x7e || data[i] == escape_char) {
			count += 3; // "xNN" - 3 bytes
		}
	}

	return count;
}

/*
 * Escapes non-printable characters in the given data, expanding it using
 * realloc() if more than *buf_size bytes are required.  The new data length is
 * stored in *data_size, and the new buffer size (if it is changed) is stored
 * in *buf_size.  If add_null is nonzero, a single zero byte is appended to the
 * escaped data.  Returns 0 on success, -1 on memory allocation error, a null
 * parameter, or if data_size and buf_size point to the same memory location.
 */
int nl_escape_data(char **data, size_t *data_size, size_t *buf_size, int add_null)
{
	char hexbuf[5];
	char *tmp, *src, *dst;
	char esc;
	size_t new_size;

	if(data == NULL || *data == NULL) {
		ERROR_OUT("Null data parameter\n");
		return -1;
	}
	if(data_size == NULL) {
		ERROR_OUT("Null data_size parameter\n");
		return -1;
	}
	if(buf_size == NULL) {
		ERROR_OUT("Null buf_size parameter\n");
		return -1;
	}
	if(data_size == buf_size) {
		// TODO: Is this really necessary?
		ERROR_OUT("Data size and buffer size cannot be stored in the same location\n");
		return -1;
	}

	new_size = *data_size + (add_null ? 1 : 0) + nl_count_data_escapes(*data, *data_size);

	// Nothing to do
	if(new_size == *data_size) {
		return 0;
	}

	// Grow the buffer
	if(new_size > *buf_size) {
		DEBUG_OUT("Growing data buffer from %zu to %zu bytes\n", *buf_size, new_size);
		tmp = realloc(*data, new_size);
		if(tmp == NULL) {
			ERRNO_OUT("Error growing data buffer from %zu to %zu bytes", *buf_size, new_size);
			return -1;
		}
		*data = tmp;
		*buf_size = new_size;
	}

	// Process the characters
	dst = *data + new_size - 1;
	src = *data + *data_size - 1;
	if(add_null) {
		*dst = 0;
		dst--;
	}

	while(dst >= *data && src >= *data) {
		esc = get_escape(*src);
		if(*src != ':' && esc != 0) {
			*dst = esc;
			dst--;
			*dst = escape_char;
			dst--;
		} else if(*src < 0x20 || *src > 0x7e || *src == escape_char) {
			snprintf(hexbuf, ARRAY_SIZE(hexbuf), "\\x%02x", (unsigned int)(*src) & 0xff);
			memcpy(dst - 3, hexbuf, 4);
			dst -= 4;
		} else {
			*dst = *src;
			dst--;
		}
		src--;
	}

	*data_size = new_size;

	return 0;
}


